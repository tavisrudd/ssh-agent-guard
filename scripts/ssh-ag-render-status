#!/bin/bash
# ssh-ag-render-status — renders ssh-agent-guard status for status bars
# Ensure coreutils + tmux are in PATH (systemd services have minimal PATH)
PATH="/run/current-system/sw/bin:/usr/bin:/bin:$PATH"
#
# Architecture:
#   1. Parse current.yaml and classify the event
#   2. Call render functions (render_notify, render_decay, render_clear)
#   3. Manage decay timers (background sleep + re-render)
#
# The render functions are overridable: place a script at
# ~/.config/ssh-ag/render.sh that redefines any of them.
# See docs/status-rendering.md for the full interface contract.
#
# Test mode:
#   --test-tmux [FILE]      print tmux output to stdout (reads stdin if no FILE)
#   --test-i3status [FILE]  print i3status output to stdout (reads stdin if no FILE)
#   --test-live-status      also update i3status + tmux (with --test-* flags)

STATE_DIR="$HOME/.local/state/ssh-ag"
CURRENT="$STATE_DIR/current.yaml"
I3STATUS="$STATE_DIR/i3status"
DECAY_PID="$STATE_DIR/.render-decay.pid"
CFG_DECAY_PID="$STATE_DIR/.render-cfg-decay.pid"
CFG_ERROR_FILE="$STATE_DIR/config_error.yaml"

# ---------------------------------------------------------------------------
# Render functions — override these in ~/.config/ssh-ag/render.sh
# ---------------------------------------------------------------------------
# All functions receive state via shell variables, not arguments.
# Available variables are documented at each call site below.

# render_notify: called when there's an active notification to display.
#
# Variables:
#   EV_TYPE   — confirming, allow, deny, confirmed, confirm-denied,
#               reloaded, reload-error, cfg-error
#   COLOR     — solarized hex color for the event (#268bd2, #dc322f, etc.)
#   TEXT      — human-readable summary string
#   CFG_ERROR — "true" if config_error.yaml exists, "false" otherwise
#
render_notify() {
    # tmux: colored background with bold text
    local tmux_prefix=""
    case "$EV_TYPE" in confirming) tmux_prefix=" ▶" ;; esac
    local tmux_cfg_suffix=""
    local i3_cfg_suffix=""
    if [ "$CFG_ERROR" = "true" ]; then
        tmux_cfg_suffix="#[bg=#dc322f,fg=#ffffff,bold] CfgErr #[default]"
        i3_cfg_suffix='<span background="#dc322f" foreground="#ffffff"> CfgErr </span>'
    fi
    local tmux_fmt="#[bg=$COLOR,fg=#ffffff,bold]${tmux_prefix} $TEXT #[default]${tmux_cfg_suffix}"
    tmux set -g @ssh_ag_status "$tmux_fmt" 2>/dev/null || true
    tmux refresh-client -S 2>/dev/null || true

    # i3status-rs: pango markup file (watched via inotify)
    printf '<span background="%s" foreground="#ffffff">  %s  </span>%s' \
        "$COLOR" "$TEXT" "$i3_cfg_suffix" > "$I3STATUS"
}

# render_decay: called when an active notification expires.
# Transitions to a residual display (timestamp, denied indicator).
#
# Variables:
#   DECAY_TIME    — "HH:MM" from the previous event, or empty
#   DECAY_DENIED  — "true" if the previous event was a denial, or empty
#   CFG_ERROR     — "true" if config_error.yaml exists (re-checked at decay time)
#
render_decay() {
    local cfg_err_i3=""
    local cfg_err_tmux=""
    if [ "$CFG_ERROR" = "true" ]; then
        cfg_err_i3=' <span background="#dc322f" foreground="#ffffff"> CfgErr </span>'
        cfg_err_tmux="#[bg=#dc322f,fg=#ffffff,bold] CfgErr #[default]"
    fi

    # i3status-rs: persistent timestamp indicator
    if [ -n "$DECAY_TIME" ]; then
        if [ "$DECAY_DENIED" = "true" ]; then
            printf '(S: %s <span foreground="#dc322f">D</span>)%s' \
                "$DECAY_TIME" "$cfg_err_i3" > "$I3STATUS"
        else
            printf '(S: %s)%s' "$DECAY_TIME" "$cfg_err_i3" > "$I3STATUS"
        fi
    elif [ -n "$cfg_err_i3" ]; then
        printf '<span background="#dc322f" foreground="#ffffff"> CfgErr </span>' > "$I3STATUS"
    else
        : > "$I3STATUS"
    fi

    # tmux: clear (or show CfgErr)
    tmux set -g @ssh_ag_status "$cfg_err_tmux" 2>/dev/null || true
    tmux refresh-client -S 2>/dev/null || true
}

# render_clear: called to clear all display (or show persistent CfgErr).
#
# Variables:
#   CFG_ERROR — "true" if config_error.yaml exists, "false" otherwise
#
render_clear() {
    if [ "$CFG_ERROR" = "true" ]; then
        printf '<span background="#dc322f" foreground="#ffffff"> CfgErr </span>' > "$I3STATUS"
        tmux set -g @ssh_ag_status "#[bg=#dc322f,fg=#ffffff,bold] CfgErr #[default]" 2>/dev/null || true
    else
        : > "$I3STATUS"
        tmux set -g @ssh_ag_status "" 2>/dev/null || true
    fi
    tmux refresh-client -S 2>/dev/null || true
}

# ---------------------------------------------------------------------------
# Source user overrides (redefine render_notify/render_decay/render_clear)
# ---------------------------------------------------------------------------
RENDER_CONF="${XDG_CONFIG_HOME:-$HOME/.config}/ssh-ag/render.sh"
if [ -f "$RENDER_CONF" ]; then
    # shellcheck source=/dev/null
    . "$RENDER_CONF"
fi

# ---------------------------------------------------------------------------
# Parse flags
# ---------------------------------------------------------------------------
TEST_MODE=""
TEST_LIVE=false
for arg in "$@"; do
    case "$arg" in
        --test-tmux)     TEST_MODE="tmux" ;;
        --test-i3status) TEST_MODE="i3status" ;;
        --test-live-status) TEST_LIVE=true ;;
    esac
done
if [ -n "$TEST_MODE" ]; then
    shift_done=false
    for arg in "$@"; do
        case "$arg" in
            --*) ;;
            *)
                if ! $shift_done; then
                    CURRENT="$arg"
                    shift_done=true
                fi
                ;;
        esac
    done
    if ! $shift_done; then
        CURRENT="/dev/stdin"
    fi
fi

# ---------------------------------------------------------------------------
# Parse current.yaml
# ---------------------------------------------------------------------------
STATE=""
TEXT=""
SECTION=""
PREV_DECISION=""
PREV_TIMESTAMP=""
PREV_CONFIRM_METHOD=""
while IFS= read -r line; do
    case "$line" in
        state:*)
            STATE="${line#state:}"
            STATE="${STATE#"${STATE%%[![:space:]]*}"}"
            SECTION=""
            ;;
        text:*)
            TEXT="${line#text:}"
            TEXT="${TEXT#"${TEXT%%[![:space:]]*}"}"
            TEXT="${TEXT#\"}"
            TEXT="${TEXT%\"}"
            TEXT="${TEXT#\'}"
            TEXT="${TEXT%\'}"
            SECTION=""
            ;;
        "previous:")
            SECTION="previous"
            ;;
        "pending:")
            SECTION="pending"
            ;;
        "    "*|"  "*)
            if [ "$SECTION" = "previous" ]; then
                stripped="${line#"${line%%[![:space:]]*}"}"
                case "$stripped" in
                    decision:*)
                        PREV_DECISION="${stripped#decision:}"
                        PREV_DECISION="${PREV_DECISION#"${PREV_DECISION%%[![:space:]]*}"}"
                        PREV_DECISION="${PREV_DECISION#\"}"
                        PREV_DECISION="${PREV_DECISION%\"}"
                        PREV_DECISION="${PREV_DECISION#\'}"
                        PREV_DECISION="${PREV_DECISION%\'}"
                        ;;
                    timestamp:*)
                        PREV_TIMESTAMP="${stripped#timestamp:}"
                        PREV_TIMESTAMP="${PREV_TIMESTAMP#"${PREV_TIMESTAMP%%[![:space:]]*}"}"
                        PREV_TIMESTAMP="${PREV_TIMESTAMP#\"}"
                        PREV_TIMESTAMP="${PREV_TIMESTAMP%\"}"
                        PREV_TIMESTAMP="${PREV_TIMESTAMP#\'}"
                        PREV_TIMESTAMP="${PREV_TIMESTAMP%\'}"
                        ;;
                    confirm_method:*)
                        PREV_CONFIRM_METHOD="${stripped#confirm_method:}"
                        PREV_CONFIRM_METHOD="${PREV_CONFIRM_METHOD#"${PREV_CONFIRM_METHOD%%[![:space:]]*}"}"
                        PREV_CONFIRM_METHOD="${PREV_CONFIRM_METHOD#\"}"
                        PREV_CONFIRM_METHOD="${PREV_CONFIRM_METHOD%\"}"
                        PREV_CONFIRM_METHOD="${PREV_CONFIRM_METHOD#\'}"
                        PREV_CONFIRM_METHOD="${PREV_CONFIRM_METHOD%\'}"
                        ;;
                esac
            fi
            ;;
    esac
done < "$CURRENT" 2>/dev/null

# ---------------------------------------------------------------------------
# Classify event
# ---------------------------------------------------------------------------
CFG_ERROR=false
CFG_ERROR_FRESH=false
if [ -f "$CFG_ERROR_FILE" ]; then
    CFG_ERROR=true
    file_mtime=$(stat -c %Y "$CFG_ERROR_FILE" 2>/dev/null || echo 0)
    now=$(date +%s)
    cfg_age=$(( now - file_mtime ))
    if [ "$cfg_age" -lt 60 ]; then
        CFG_ERROR_FRESH=true
    fi
fi

# EV_TYPE drives all rendering dispatch; COLOR is the hex value
EV_TYPE=""
COLOR=""
if [ "$STATE" = "reloaded" ]; then
    if $CFG_ERROR; then
        EV_TYPE="reload-error"
        COLOR="#dc322f"
        TEXT="CFG ERR: policy reload failed"
    else
        EV_TYPE="reloaded"
        COLOR="#859900"
        TEXT="config reloaded"
    fi
elif [ "$STATE" = "confirming" ]; then
    EV_TYPE="confirming"
    COLOR="#cb4b16"
elif [ "$STATE" = "idle" ] && [ -n "$PREV_DECISION" ]; then
    EV_TYPE="$PREV_DECISION"
    case "$PREV_DECISION" in
        allow|confirmed)     COLOR="#268bd2" ;;
        deny|confirm-denied) COLOR="#dc322f" ;;
    esac
fi

# Config error display logic (for non-reload states):
#   Sign events take priority — render_notify gets CFG_ERROR for suffix
#   Fresh (<60s) + no sign event: show prominent "CFG ERR" notification
#   Stale (>=60s) + no sign event: persistent indicator only (via render_clear)
if $CFG_ERROR && [ "$STATE" != "reloaded" ]; then
    if [ -z "$EV_TYPE" ] && $CFG_ERROR_FRESH; then
        EV_TYPE="cfg-error"
        COLOR="#dc322f"
        TEXT="CFG ERR: policy reload failed"
    fi
fi

# ---------------------------------------------------------------------------
# Test mode: print formatted output to stdout
# ---------------------------------------------------------------------------
if [ -n "$TEST_MODE" ]; then
    case "$TEST_MODE" in
        i3status)
            if [ -n "$EV_TYPE" ]; then
                local_cfg_suffix=""
                if [ "$CFG_ERROR" = "true" ] && [ -n "$EV_TYPE" ]; then
                    local_cfg_suffix='<span background="#dc322f" foreground="#ffffff"> CfgErr </span>'
                fi
                printf '<span background="%s" foreground="#ffffff">  %s  </span>%s\n' \
                    "$COLOR" "$TEXT" "$local_cfg_suffix"
            else
                printf '(idle)\n'
            fi
            ;;
        tmux)
            if [ -n "$EV_TYPE" ]; then
                local_prefix=""
                case "$EV_TYPE" in confirming) local_prefix=" ▶" ;; esac
                local_cfg_suffix=""
                if [ "$CFG_ERROR" = "true" ]; then
                    local_cfg_suffix="#[bg=#dc322f,fg=#ffffff,bold] CfgErr #[default]"
                fi
                printf '#[bg=%s,fg=#ffffff,bold]%s %s #[default]%s\n' \
                    "$COLOR" "$local_prefix" "$TEXT" "$local_cfg_suffix"
            else
                printf '(empty)\n'
            fi
            ;;
    esac
    if ! $TEST_LIVE; then
        exit 0
    fi
fi

# ---------------------------------------------------------------------------
# Live mode: render + manage decay timers
# ---------------------------------------------------------------------------

# Kill any existing decay timers
if [ -f "$DECAY_PID" ]; then
    kill "$(cat "$DECAY_PID")" 2>/dev/null
    rm -f "$DECAY_PID"
fi
if [ -f "$CFG_DECAY_PID" ]; then
    kill "$(cat "$CFG_DECAY_PID")" 2>/dev/null
    rm -f "$CFG_DECAY_PID"
fi

# Render the current state
if [ -n "$EV_TYPE" ]; then
    render_notify
elif $CFG_ERROR; then
    render_clear
else
    render_clear
fi

# ---------------------------------------------------------------------------
# Decay timers
# ---------------------------------------------------------------------------
# Config error decay: after 60s, transition from prominent to persistent
if $CFG_ERROR_FRESH && [ "$STATE" != "reloaded" ]; then
    remaining=$(( 60 - cfg_age ))
    (
        sleep "$remaining"
        if [ -f "$CFG_ERROR_FILE" ]; then
            CFG_ERROR=true render_clear
        fi
        rm -f "$CFG_DECAY_PID"
    ) &
    echo $! > "$CFG_DECAY_PID"
fi

# Reload: 3s decay for success, 60s for error
if [ "$EV_TYPE" = "reloaded" ]; then
    (
        sleep 3
        CFG_ERROR=false render_clear
        rm -f "$DECAY_PID"
    ) &
    echo $! > "$DECAY_PID"
elif [ "$EV_TYPE" = "reload-error" ]; then
    (
        sleep 60
        CFG_ERROR=$( [ -f "$CFG_ERROR_FILE" ] && echo true || echo false )
        render_clear
        rm -f "$DECAY_PID"
    ) &
    echo $! > "$DECAY_PID"
fi

# Idle results: decay after variable timeout
if [ "$STATE" = "idle" ] && [ -n "$EV_TYPE" ]; then
    DECAY_TIME=""
    if [ -n "$PREV_TIMESTAMP" ]; then
        DECAY_TIME="${PREV_TIMESTAMP#*T}"
        DECAY_TIME="${DECAY_TIME%:*}"  # HH:MM (strip seconds)
    fi
    DECAY_DENIED=""
    DECAY_SECS=10
    case "$PREV_DECISION" in
        allow)           DECAY_SECS=5 ;;
        confirmed)       DECAY_SECS=2 ;;
        deny)
            if [ "$PREV_CONFIRM_METHOD" = "missing" ]; then
                DECAY_SECS=20
            else
                DECAY_SECS=10
            fi
            DECAY_DENIED=true
            ;;
        confirm-denied)  DECAY_SECS=10; DECAY_DENIED=true ;;
    esac
    (
        sleep "$DECAY_SECS"
        CFG_ERROR=$( [ -f "$CFG_ERROR_FILE" ] && echo true || echo false )
        render_decay
        rm -f "$DECAY_PID"
    ) &
    echo $! > "$DECAY_PID"
fi
